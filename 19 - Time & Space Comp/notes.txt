TIME AND SPACE COMPLEXITY

the time and space are calculated with respect to the input size

order complexity analysis : parameters : tima and space 

time complexity : amount of time taken by an algorithm wrt the input size, this is not the actual time taken

there can be different time complexities:
time = function(input size)

1. Constant O(1)
2. Log O (logn)
3. Linear O (n)
4. Linear * Log O(nlogn)
5. Quadratic O(n^2)
6. Exponential O(2^n)
7. Factorial O(n!)

there are two ways to calculate time complexities : experimental , theorotical
we always try to find thes worst case time

* Cormenn book 

Big O Notation 
this gives the worst case or the upper bound

if time => an^2 + bn + c 
ignore constants, take largest term
time = f(n^2), therefore time complexity O(n^2)

if time => an^3 + blogn + c
Time => O(n^3)

f(n) = O(g(n))

lim n -> infinity |f(n)| / g(n) < infinity

Big omega Notation

this represents the best case time and the lower bound 

Theta Notation

this represents the average time of all the inputs for the algorithm 

small O , small omega, small theta represents the precision in the calculation of the values of complexities

SPACE COMPLEXITY 

memory space -> heap(objects, variables, arrays) and stack (function calls) 

input space + auxiliary space (temperory variables, arrays rewuired for the algoithms)  


Loop analysis 

for(int i=0; i<n; i++){
    // some constant work k 
}

for a simple loop we check the number of operations 
O(n * k) -> O(n)


nested loop 

for(int i=0; <n; i++){
    for(int j=i+1; j<n; j++){
        // some constant work k
    }
}

n-1 + n-2 + n-3 + .... 0

n(n+1) / 2 -> O(n^2) 

nested loop 2 

for(int i =0; i<n; i++){
    for int j=0; j<i; j++
{
    some constant work -> k
}}


k + 2k + 3k + 4k + .... (n-1) k = k (n (n-1)) / 2 -> O(n^2)

nested loop 3 

for(int i=0; i<n; i = i+k){
    for(int j=i+1; j<=k; j++){
        // some cnst work -> p
    }
}

O(n / k * k * p) -> O(n)


Bubble sort : k(n + n-1 + n-2 ...) -> o(n^2)

modified bubble sort -> worst case O(n^2)
                        best case -> O(n)


Binary Search ->

n -> n/2 -> n/4 -> n/8 ... 1 
n / 2^k = 1 
O(logn)